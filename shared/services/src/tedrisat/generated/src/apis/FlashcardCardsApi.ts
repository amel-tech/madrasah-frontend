/* tslint:disable */
/* eslint-disable */
/**
 * Tedrisat Service API
 * Education management service for Madrasah platform
 *
 * The version of the OpenAPI document: 0.1.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateFlashcardDto,
  CreateFlashcardProgressDto,
  FlashcardProgressResponse,
  FlashcardResponse,
  UpdateFlashcardDto,
} from '../models/index';
import {
    CreateFlashcardDtoFromJSON,
    CreateFlashcardDtoToJSON,
    CreateFlashcardProgressDtoFromJSON,
    CreateFlashcardProgressDtoToJSON,
    FlashcardProgressResponseFromJSON,
    FlashcardProgressResponseToJSON,
    FlashcardResponseFromJSON,
    FlashcardResponseToJSON,
    UpdateFlashcardDtoFromJSON,
    UpdateFlashcardDtoToJSON,
} from '../models/index';

export interface CreateFlashcardsRequest {
    deckId: string;
    createFlashcardDto: Array<CreateFlashcardDto>;
}

export interface DeleteFlashcardRequest {
    id: string;
}

export interface GetFlashcardByDeckIdRequest {
    deckId: string;
    include?: Array<GetFlashcardByDeckIdIncludeEnum>;
}

export interface GetFlashcardByIdRequest {
    id: string;
    include?: Array<GetFlashcardByIdIncludeEnum>;
}

export interface ReplaceFlashcardRequest {
    id: string;
    createFlashcardDto: CreateFlashcardDto;
}

export interface ReplaceManyFlashcardProgressRequest {
    createFlashcardProgressDto: Array<CreateFlashcardProgressDto>;
}

export interface UpdateFlashcardRequest {
    id: string;
    updateFlashcardDto: UpdateFlashcardDto;
}

/**
 * 
 */
export class FlashcardCardsApi extends runtime.BaseAPI {

    /**
     * Creates multiple flashcards within a specified deck. All cards will be assigned to the same deck and author.
     * Create multiple flashcards in a deck
     */
    async createFlashcardsRaw(requestParameters: CreateFlashcardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FlashcardResponse>>> {
        if (requestParameters['deckId'] == null) {
            throw new runtime.RequiredError(
                'deckId',
                'Required parameter "deckId" was null or undefined when calling createFlashcards().'
            );
        }

        if (requestParameters['createFlashcardDto'] == null) {
            throw new runtime.RequiredError(
                'createFlashcardDto',
                'Required parameter "createFlashcardDto" was null or undefined when calling createFlashcards().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/flashcard/decks/{deckId}/cards`;
        urlPath = urlPath.replace(`{${"deckId"}}`, encodeURIComponent(String(requestParameters['deckId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['createFlashcardDto']!.map(CreateFlashcardDtoToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlashcardResponseFromJSON));
    }

    /**
     * Creates multiple flashcards within a specified deck. All cards will be assigned to the same deck and author.
     * Create multiple flashcards in a deck
     */
    async createFlashcards(requestParameters: CreateFlashcardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FlashcardResponse>> {
        const response = await this.createFlashcardsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Permanently deletes a flashcard by its ID. This action cannot be undone.
     * Delete a flashcard
     */
    async deleteFlashcardRaw(requestParameters: DeleteFlashcardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteFlashcard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/flashcard/cards/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Permanently deletes a flashcard by its ID. This action cannot be undone.
     * Delete a flashcard
     */
    async deleteFlashcard(requestParameters: DeleteFlashcardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFlashcardRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves all flashcards by matching a deck identifier
     * Get all flashcards from a deck
     */
    async getFlashcardByDeckIdRaw(requestParameters: GetFlashcardByDeckIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FlashcardResponse>>> {
        if (requestParameters['deckId'] == null) {
            throw new runtime.RequiredError(
                'deckId',
                'Required parameter "deckId" was null or undefined when calling getFlashcardByDeckId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['deckId'] != null) {
            queryParameters['deckId'] = requestParameters['deckId'];
        }

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/flashcard/cards`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlashcardResponseFromJSON));
    }

    /**
     * Retrieves all flashcards by matching a deck identifier
     * Get all flashcards from a deck
     */
    async getFlashcardByDeckId(requestParameters: GetFlashcardByDeckIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FlashcardResponse>> {
        const response = await this.getFlashcardByDeckIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a specific flashcard by its unique identifier
     * Get a single flashcard
     */
    async getFlashcardByIdRaw(requestParameters: GetFlashcardByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlashcardResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getFlashcardById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/flashcard/cards/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FlashcardResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a specific flashcard by its unique identifier
     * Get a single flashcard
     */
    async getFlashcardById(requestParameters: GetFlashcardByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlashcardResponse> {
        const response = await this.getFlashcardByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replaces all properties of an existing flashcard with new values. This is a complete replacement operation.
     * Replace a flashcard completely
     */
    async replaceFlashcardRaw(requestParameters: ReplaceFlashcardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlashcardResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling replaceFlashcard().'
            );
        }

        if (requestParameters['createFlashcardDto'] == null) {
            throw new runtime.RequiredError(
                'createFlashcardDto',
                'Required parameter "createFlashcardDto" was null or undefined when calling replaceFlashcard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/flashcard/cards/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CreateFlashcardDtoToJSON(requestParameters['createFlashcardDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FlashcardResponseFromJSON(jsonValue));
    }

    /**
     * Replaces all properties of an existing flashcard with new values. This is a complete replacement operation.
     * Replace a flashcard completely
     */
    async replaceFlashcard(requestParameters: ReplaceFlashcardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlashcardResponse> {
        const response = await this.replaceFlashcardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create or update flashcard progress
     */
    async replaceManyFlashcardProgressRaw(requestParameters: ReplaceManyFlashcardProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FlashcardProgressResponse>>> {
        if (requestParameters['createFlashcardProgressDto'] == null) {
            throw new runtime.RequiredError(
                'createFlashcardProgressDto',
                'Required parameter "createFlashcardProgressDto" was null or undefined when calling replaceManyFlashcardProgress().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/flashcard/cards/progress`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['createFlashcardProgressDto']!.map(CreateFlashcardProgressDtoToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FlashcardProgressResponseFromJSON));
    }

    /**
     * Create or update flashcard progress
     */
    async replaceManyFlashcardProgress(requestParameters: ReplaceManyFlashcardProgressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FlashcardProgressResponse>> {
        const response = await this.replaceManyFlashcardProgressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates specific properties of an existing flashcard. Only provided fields will be updated.
     * Update a flashcard partially
     */
    async updateFlashcardRaw(requestParameters: UpdateFlashcardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FlashcardResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateFlashcard().'
            );
        }

        if (requestParameters['updateFlashcardDto'] == null) {
            throw new runtime.RequiredError(
                'updateFlashcardDto',
                'Required parameter "updateFlashcardDto" was null or undefined when calling updateFlashcard().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/flashcard/cards/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateFlashcardDtoToJSON(requestParameters['updateFlashcardDto']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FlashcardResponseFromJSON(jsonValue));
    }

    /**
     * Updates specific properties of an existing flashcard. Only provided fields will be updated.
     * Update a flashcard partially
     */
    async updateFlashcard(requestParameters: UpdateFlashcardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FlashcardResponse> {
        const response = await this.updateFlashcardRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetFlashcardByDeckIdIncludeEnum = {
    Progress: 'progress'
} as const;
export type GetFlashcardByDeckIdIncludeEnum = typeof GetFlashcardByDeckIdIncludeEnum[keyof typeof GetFlashcardByDeckIdIncludeEnum];
/**
 * @export
 */
export const GetFlashcardByIdIncludeEnum = {
    Progress: 'progress'
} as const;
export type GetFlashcardByIdIncludeEnum = typeof GetFlashcardByIdIncludeEnum[keyof typeof GetFlashcardByIdIncludeEnum];
